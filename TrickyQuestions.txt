// Tricky Question with Answers


1)  let a = 5
    let b = a++;
    console.log(a + b)
    O/P => 11 (due to postprefix operator a becomes 6 in second line)


2)  const a = 1<2<3; // true because (1<2 return true which is 1 again 1<3 will return true)
    const b = 3<2<1; // true (3<2 returns false == 0 and (0<1) == true  )
    console.log(a,b)


3)  const arr = [1,2,3]
    arr[5] = 99;
    console.log(arr) O/P =[1,2,3,undefined,undefined,99]
    console.log(arr.length) O/P = 5


4)  let str = 'jscafe'
    str[0] = 'c'
    console.log(str) O/P = 'jscafe' (because string is immutable we can change entire 
    string instead we cannot changed string value based on index)


5)  console.log(5<'15'<5) // true (due to type coresion 15 is converted to number(5<15)=1 and (1<5)=true)
    console.log(7<'15'<7) // true (due to type coresion 15 is converted to number(7<15)=1 and (1<5)=true)
    console.log(7<'85'>5) // false (due to type coresion 85 is converted to number(7<85)=1 and (1>5)=false)


6)  console.log(1)
    setTimeout(()=>{
        console.log(2)
    },1000)
    setTimeout(()=>{
        console.log(3)
    })
    console.log(4)

    OP =>
        1
        4
        3
        2
    Promises will moved to microtask queue and settimeout will be moved to task queue


7)  num = 6;
    console.log(num); // ReferenceError: Cannot access 'num' before initialization 
    let num;


8) console.log(typeof typeof 1) // string (because typeof 1 ="number" which is in string (typeof "number") = string)


9)  const a = 5
    const b = new Number(5)
    console.log(a==b) // it will check only the value
    console.log(a===b) // it will check data type also (here new keyword will create object so (Number = object) == false)


10) let promise1 = new Promise((res, rej) => {
        setTimeout(res, '500', 'one')
    })
    let promise2 = new Promise((res, rej) => {
        setTimeout(res, '100', 'two')
    })
    
    Promise.race([promise1, promise2]).then((res) => {
        console.log(res)
    })
    
    OP => two (Promise.race will wait for any one of the promise to either resolve or reject)


11) let num =0
    console.log(num++) // 0 since it has postfix operator it will log and increment num so after logging num becomes 1
    console.log(++num) // 2 since num is 1 when it reaches this line due to prefix operator it adds one so num =2


12) getData()
    getData1()
    getData2()

    function getData() {
        console.log('hello1')
    }

    var getData1 = () => {
        console.log('hello2')
    }

    const getData2 = () => {
        console.log('hello3')
    }

OP >>
    hello1
    TypeError: getData1 is not a function (whenever we declare a variable with var it will hoisted and assigned a undefined as value so it is throwing type error)
    ReferenceError: Cannot access 'getData1' before initialization (let and const will throw error as we are accessing it before intialization)
  
    

13) function func(){
        try {
            console.log(1)
            return
        } catch (error) {
           console.log(2) 
        }finally{
            console.log(3)
        }
        console.log(4)
    }
    func();
    
    OP>> 
        1
        3

(It is because try block will be executed due to return it will exit from function not completely it will execute finally block even though there is a return statement)
    

14) console.log([] == []) // false (since array are refrence type it will be stored in different memory locations so when comapring the location it will return false)
    console.log([] == ![]) // true



15) for (var index = 0; index < 3; index++) {
        setTimeout(() => {
            console.log(index)
        }, 0)
    }

    op>> 
        3
        3
        3
(since var is function scope and set timeout is asynchronous it will take time to complete so for loop will run and index will be 3 and the settimout will be called)
